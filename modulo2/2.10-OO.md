1. Considerando a convenção de nomenclatura que emula o pilar de encapsulamento em Python, qual das alternativas está correta?
a) Atributos públicos são precedidos por um underscore (_).
b) Atributos protegidos seguem o padrão snake_case, enquanto privados seguem o padrão camelCase.
**c) Atributos precedidos por um underscore (_) ou dois underscores (__) não devem ser acessados publicamente.**
d) Atributos precedidos por uma hashtag (`#`) são destinados ao uso interno da classe.

2. O que acontece com os atributos de uma classe que são precedidos por dois underscores (__)?
a) Não são acessíveis pelas instâncias da classe.
b) São automaticamente convertidos em variáveis globais.
**c) Têm seus nomes alterados pela prática de embaralhamento de nomes.**
d) São acessíveis pela classe e pelas instâncias, porém são imutáveis.

3. Qual das alternativas abaixo descreve corretamente a função de cada tipo de decorador em Python?
a) `@property` cria uma propriedade, ou seja, um método que recebe como primeiro parâmetro uma referência à instância que o chamou, permitindo modificar atributos dessa instância.
b) `@staticmethod` permite que um método acesse atributos da classe diretamente, sem precisar de uma instância da classe.
**c) `@classmethod` transforma um método para que ele receba como primeiro parâmetro uma referência à própria classe, permitindo modificar atributos de classe.**
d) `@property` e `@staticmethod` são utilizados exclusivamente para definir métodos privados.

4. Considere a classe a seguir.
```
class Exemplo:
    def __init__(self, valor=1):
        self._valor_positivo = valor

    @property
    def valor_positivo(self):
        return self._valor_positivo

    @valor_positivo.setter
    def valor_positivo(self, novo_valor):
        if novo_valor > 0:
            self._valor_positivo = novo_valor
        else:
            raise ValueError("O valor deve ser positivo.")
```

Analise as afirmativas:
(I) O underscore no início do nome do atributo `_valor_positivo` sugere que ele não deve ser acessado publicamente.
(II) Os métodos decorados definem o `getter` e o `setter` de uma `property` do Python, sendo intermediários para manipular o atributo `_valor_positivo`.
(III) Instanciar um objeto `ex1 = Exemplo(-1)` não lançará erro, porém a atribuição `ex2.valor_positivo = -1` de um objeto `ex2 = Exemplo()` lançará `ValueError`.
(IV) Ao criar uma instância `ex = Exemplo(10)`, o interpretador é capaz de recuperar o valor armazenado em `ex` tanto via `ex._valor_positivo` quanto via `ex.valor_positivo`.

Quais afirmativas são verdadeiras?
a) I e II apenas.
b) II e III apenas.
c) I, III e IV apenas.
**d) I, II, III e IV.**

5. Sobre o pilar Herança e sua expressão na linguagem Python, qual das afirmativas a seguir está correta?
a) Para implementar uma relação de herança, a classe deve utilizar o decorador `@inherits`. O decorador aceita como parâmetro a lista de superclasses desejadas.
b) Através do método especial `__mro__()` podemos resolver conflitos de sobrescrita de métodos em casos de herança múltipla, definindo qual método deve prevalecer na subclasse.  
c) Python não suporta sobrescrita de métodos em subclasses, já que instâncias de uma subclasse devem explicitar o nome da classe da hierarquia ao invocar um método.
**d) Todas as classes em Python herdam da classe nativa `object`, ou seja, `object` sempre será o último elemento no atributo especial `__mro__` de uma classe customizada.**

6. Sobre tratamento de erros no Python, analise as afirmativas a seguir.
I) Uma exceção é um evento que ocorre durante a execução de um programa e interrompe o fluxo das instruções, mas não pode ser tratado pelo próprio programa.
II) O comando `raise` permite lançar exceções deliberadamente, sejam exceções incluídas na linguagem ou customizadas por nós.
III) Ao criar um bloco `try ... except` sem especificar uma exceção, assume-se `BaseException`, que está na base da hierarquia de exceções. 
IV) A hierarquia de herança das exceções não influencia a escolha da ordem das instruções `except`,   já que todas as exceções de um bloco `try ... except ... except ...` são avaliadas e seus respectivos tratamentos aplicados.

Assinale a alternativa que corresponde à sequência correta de Verdadeiro (V) ou Falso (F):
a) VVVF 
b) FVVF
c) VFFV
**d) FVVV**


7. Sobre o pilar da abstração na orientação a objetos em Python, qual das alternativas é correta?

a) Em Python, não é possível criar interfaces porque a linguagem não suporta abstração.
b) Classes são consideradas abstratas se suas subclasses sobrescrevem métodos já existentes, inutilizando os métodos da superclasse.
**c) Subclasses que herdam de classes abstratas são obrigadas a sobrescrever os métodos abstratos da superclasse, ou seja, aqueles com o decorador `@abstractmethod` do módulo `abc` (abstract base class).**
d) Para criar uma classe abstrata em Python basta que ela herde da classe `ABC` (Abstract Base Class) do módulo `abc`.

8. Sobre o pilar do polimorfismo na orientação a objetos em Python, qual das alternativas é correta?

**a) Para satisfazer o estilo de programação duck typing basta que dois objetos implementem o mesmo conjunto de comportamentos necessários em um dado contexto.**  
b) Por ser uma linguagem fracamente tipada, duck typing é a única expressão do polimorfismo no Python.
c) Polimorfismo permite tratar objetos de diferentes tipos como o mesmo tipo geral, contanto que eles herdem da mesma superclasse.
d) Através do polimorfismo podemos invocar um método em um dado objeto mesmo que ele não seja implementado por sua classe de origem.